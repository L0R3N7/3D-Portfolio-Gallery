\subsubsection{Framework [M]}
\setauthor{Fabian Maar}

Ein Framework soll dem*der Programmierer*in helfen neue Applikationen zu schaffen. Es bietet somit ein Grundgerüst, auf dass sich die Software aufbauen lässt. \cite{Framework}  

\subsubsection{Open-Source [L]}
\setauthor{Lorenz Litzlbauer}
Bei einer Open Source Applikation ist der Code öffentlich zugänglich. Der Open Source Status sagt aber nichts über die Lizenzierung der Applikation aus. \cite{WhatOpenSource}

\subsubsection{Single-Page-Application (SPA) [M]}
\setauthor{Fabian Maar}
Eine Single-Page-Webanwendung interagiert mit dem*der User*in, wodurch sich einzelne Komponenten der Website dynamisch verändern. //TODO

\subsubsection{Design-Pattern [L]}
\setauthor{Lorenz Litzlbauer}
Im Programmieren gibt es Probleme, die immer wieder auftreten. Diese Probleme wurden schon einmal sehr effizient gelöst und es besteht kein Nutzen sie immer wieder zu lösen. Design Patterns sind Strategien und Implementierungsvorgaben für die Lösung dieser Probleme. Sie beschleunigen den Entwicklungsprozess und machen ihn sicher, weil die Implementierungsvorgaben schon vorgegeben sind und diese auf einen hohen Grad der Sicherheit getestet wurden. \cite{DesignPatterns}

\paragraph{Observer design pattern}
\label{txt:glos:observerDesignPattern}
Ein konkretes Beispiel für Design Patterns ist das \emph{Observer pattern}. Es wird dafür verwendet, Eins-zu-Eins-Beziehungen zwischen zwei oder mehreren Objekten zu erstellen. Ziel ist, dass Objekte (oder auch das Subject) bei allen Veränderungen diese schnell und leicht an das Objekt(oder auch den Observer) weitergeben.  Das Subject führt eine Liste von Observern. Sobald Änderungen auftreten, liest das Subject die Liste aus und informiert alle eingetragenen Observer. Wenn ein Objekt ein Observer werden will, muss es sich in die Liste des zu observierenden Objekt einschreiben. Ohne diese Funktionalität müsste der Observer in einem regelmäßigen Intervall das Subject abfragen, ob es eine Veränderung gab, die die Rechenzeit und Leistung verlängert würden. \cite{ObserverPatternExplaination}

\subsubsection{Event-Listener [M]}
\setauthor{Fabian Maar}
\label{txt:glos:event-listener}
Event-Listener sind Methoden, die beliebige Logik enthalten und aufgerufen werden, wenn ein bestimmtes Event eintritt. Events können zum Beispiel Interaktion von Benutzer*innen über die Maus sein. 

\subsubsection{Third-Party [M]}
\setauthor{Fabian Maar}
Sind Funktionen, Services, Libaries etc., die von Drittanbietern bereitgestellt werden, also nicht direkt zum eigentlichen Produkt gehören. 

\subsubsection{API [L]}
\label{txt:glos:API}
Eine Applikations-Programmierung-Schnittstelle bietet einen Kommunikationsweg zu einem Service oder einer Applikation ohne von der Implementation, dem Aufbau und dem Hintergrund von dieser Applikation wissen zu müssen. \cite{WhatApi}

\subsubsection{DOM [M]}
\label{txt:glos:DOM}
\setauthor{Fabian Maar}
//TODO 
\subsubsection{Shadow-DOM}


\subsubsection{Direktiven [M]}
\label{txt:glos:Direktiven}
\setauthor{Fabian Maar}
Direktiven sind Angular-spezifische Elemente, die zu einem DOM-Element hinzugefügt werden und dabei dessen Verhalten verändern können. \cite{Direktiven}

\subsubsection{Pipes [M]}
\label{txt:glos:Pipes}
\setauthor{Fabian Maar}
Pipes sind Funktionen, die einen oder mehrere Operatoren beinhalten. Dabei werden Datensätze, welche durch eine Pipe gesendet werden, durch die verschiedenen Operatoren verändert und manipuliert. \cite{Pipes}

\subsubsection{Optionals [M]}
\setauthor{Fabian Maar}
//TODO

\subsubsection{Mockup}
//TODO


\subsubsection{Evolutionäres Prototyping [L]}
\setauthor{Litzlbauer Lorenz}
\label{ch::ongoing-prototyping}
Beim evolutionären Prototyping wird der Prototyp über die Dauer des gesamten Projektes weiterentwickelt. Dies soll vermeiden, dass Fehler und Missverständnisse aus der Spezifikationsphase eines Projektes erst zu einem späten Projektstand entdeckt werden. \cite{Prototyping}